// Code generated by protoc-gen-go. DO NOT EDIT.
// source: unrar.proto

package media_manager

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type UnrarRequest struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Id       string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *UnrarRequest) Reset()                    { *m = UnrarRequest{} }
func (m *UnrarRequest) String() string            { return proto.CompactTextString(m) }
func (*UnrarRequest) ProtoMessage()               {}
func (*UnrarRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *UnrarRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *UnrarRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type UnrarResponse struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*UnrarResponse_Accepted_
	//	*UnrarResponse_Status_
	//	*UnrarResponse_Completed_
	Type isUnrarResponse_Type `protobuf_oneof:"type"`
}

func (m *UnrarResponse) Reset()                    { *m = UnrarResponse{} }
func (m *UnrarResponse) String() string            { return proto.CompactTextString(m) }
func (*UnrarResponse) ProtoMessage()               {}
func (*UnrarResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

type isUnrarResponse_Type interface {
	isUnrarResponse_Type()
}

type UnrarResponse_Accepted_ struct {
	Accepted *UnrarResponse_Accepted `protobuf:"bytes,2,opt,name=accepted,oneof"`
}
type UnrarResponse_Status_ struct {
	Status *UnrarResponse_Status `protobuf:"bytes,3,opt,name=status,oneof"`
}
type UnrarResponse_Completed_ struct {
	Completed *UnrarResponse_Completed `protobuf:"bytes,4,opt,name=completed,oneof"`
}

func (*UnrarResponse_Accepted_) isUnrarResponse_Type()  {}
func (*UnrarResponse_Status_) isUnrarResponse_Type()    {}
func (*UnrarResponse_Completed_) isUnrarResponse_Type() {}

func (m *UnrarResponse) GetType() isUnrarResponse_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *UnrarResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UnrarResponse) GetAccepted() *UnrarResponse_Accepted {
	if x, ok := m.GetType().(*UnrarResponse_Accepted_); ok {
		return x.Accepted
	}
	return nil
}

func (m *UnrarResponse) GetStatus() *UnrarResponse_Status {
	if x, ok := m.GetType().(*UnrarResponse_Status_); ok {
		return x.Status
	}
	return nil
}

func (m *UnrarResponse) GetCompleted() *UnrarResponse_Completed {
	if x, ok := m.GetType().(*UnrarResponse_Completed_); ok {
		return x.Completed
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UnrarResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UnrarResponse_OneofMarshaler, _UnrarResponse_OneofUnmarshaler, _UnrarResponse_OneofSizer, []interface{}{
		(*UnrarResponse_Accepted_)(nil),
		(*UnrarResponse_Status_)(nil),
		(*UnrarResponse_Completed_)(nil),
	}
}

func _UnrarResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UnrarResponse)
	// type
	switch x := m.Type.(type) {
	case *UnrarResponse_Accepted_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Accepted); err != nil {
			return err
		}
	case *UnrarResponse_Status_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Status); err != nil {
			return err
		}
	case *UnrarResponse_Completed_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Completed); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UnrarResponse.Type has unexpected type %T", x)
	}
	return nil
}

func _UnrarResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UnrarResponse)
	switch tag {
	case 2: // type.accepted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UnrarResponse_Accepted)
		err := b.DecodeMessage(msg)
		m.Type = &UnrarResponse_Accepted_{msg}
		return true, err
	case 3: // type.status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UnrarResponse_Status)
		err := b.DecodeMessage(msg)
		m.Type = &UnrarResponse_Status_{msg}
		return true, err
	case 4: // type.completed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UnrarResponse_Completed)
		err := b.DecodeMessage(msg)
		m.Type = &UnrarResponse_Completed_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UnrarResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UnrarResponse)
	// type
	switch x := m.Type.(type) {
	case *UnrarResponse_Accepted_:
		s := proto.Size(x.Accepted)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UnrarResponse_Status_:
		s := proto.Size(x.Status)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UnrarResponse_Completed_:
		s := proto.Size(x.Completed)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UnrarResponse_Accepted struct {
	Successful bool `protobuf:"varint,1,opt,name=successful" json:"successful,omitempty"`
}

func (m *UnrarResponse_Accepted) Reset()                    { *m = UnrarResponse_Accepted{} }
func (m *UnrarResponse_Accepted) String() string            { return proto.CompactTextString(m) }
func (*UnrarResponse_Accepted) ProtoMessage()               {}
func (*UnrarResponse_Accepted) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 0} }

func (m *UnrarResponse_Accepted) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type UnrarResponse_Status struct {
	Completed int32 `protobuf:"varint,1,opt,name=completed" json:"completed,omitempty"`
	Total     int32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`
}

func (m *UnrarResponse_Status) Reset()                    { *m = UnrarResponse_Status{} }
func (m *UnrarResponse_Status) String() string            { return proto.CompactTextString(m) }
func (*UnrarResponse_Status) ProtoMessage()               {}
func (*UnrarResponse_Status) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 1} }

func (m *UnrarResponse_Status) GetCompleted() int32 {
	if m != nil {
		return m.Completed
	}
	return 0
}

func (m *UnrarResponse_Status) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type UnrarResponse_Completed struct {
	Successful bool `protobuf:"varint,1,opt,name=successful" json:"successful,omitempty"`
}

func (m *UnrarResponse_Completed) Reset()                    { *m = UnrarResponse_Completed{} }
func (m *UnrarResponse_Completed) String() string            { return proto.CompactTextString(m) }
func (*UnrarResponse_Completed) ProtoMessage()               {}
func (*UnrarResponse_Completed) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 2} }

func (m *UnrarResponse_Completed) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

func init() {
	proto.RegisterType((*UnrarRequest)(nil), "media_manager.UnrarRequest")
	proto.RegisterType((*UnrarResponse)(nil), "media_manager.UnrarResponse")
	proto.RegisterType((*UnrarResponse_Accepted)(nil), "media_manager.UnrarResponse.Accepted")
	proto.RegisterType((*UnrarResponse_Status)(nil), "media_manager.UnrarResponse.Status")
	proto.RegisterType((*UnrarResponse_Completed)(nil), "media_manager.UnrarResponse.Completed")
}

func init() { proto.RegisterFile("unrar.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 273 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0x4f, 0x4b, 0xc4, 0x30,
	0x10, 0xc5, 0xdb, 0xee, 0xb6, 0xb4, 0xb3, 0xae, 0x87, 0xe0, 0xa1, 0x14, 0x11, 0x59, 0x51, 0x44,
	0xa1, 0x07, 0xbd, 0x89, 0x1e, 0x74, 0x41, 0x7a, 0x8e, 0x78, 0x96, 0x98, 0xce, 0x4a, 0xa1, 0x6d,
	0x62, 0x93, 0x1c, 0xfc, 0x0a, 0x7e, 0x6a, 0x69, 0xfa, 0xc7, 0xee, 0xa5, 0x7b, 0x9c, 0xc9, 0xfb,
	0xbd, 0xf7, 0x92, 0xc0, 0xca, 0xd4, 0x0d, 0x6b, 0x52, 0xd9, 0x08, 0x2d, 0xc8, 0xba, 0xc2, 0xbc,
	0x60, 0x1f, 0x15, 0xab, 0xd9, 0x17, 0x36, 0x9b, 0x07, 0x38, 0x7a, 0x6f, 0x4f, 0x29, 0x7e, 0x1b,
	0x54, 0x9a, 0x24, 0x10, 0xee, 0x8a, 0x12, 0x6b, 0x56, 0x61, 0xec, 0x9e, 0xbb, 0xd7, 0x11, 0x1d,
	0x67, 0x72, 0x0c, 0x5e, 0x91, 0xc7, 0x9e, 0xdd, 0x7a, 0x45, 0xbe, 0xf9, 0x5d, 0xc0, 0xba, 0x87,
	0x95, 0x14, 0xb5, 0x1a, 0x14, 0xee, 0xa0, 0x20, 0x5b, 0x08, 0x19, 0xe7, 0x28, 0x35, 0x76, 0xdc,
	0xea, 0xee, 0x32, 0xdd, 0xcb, 0x4f, 0xf7, 0xf8, 0xf4, 0xb9, 0x17, 0x67, 0x0e, 0x1d, 0x41, 0xf2,
	0x04, 0x81, 0xd2, 0x4c, 0x1b, 0x15, 0x2f, 0xac, 0xc5, 0xc5, 0xac, 0xc5, 0x9b, 0x95, 0x66, 0x0e,
	0xed, 0x21, 0xf2, 0x0a, 0x11, 0x17, 0x95, 0x2c, 0xb1, 0x2d, 0xb1, 0xb4, 0x0e, 0x57, 0xb3, 0x0e,
	0xdb, 0x41, 0x9d, 0x39, 0xf4, 0x1f, 0x4d, 0x6e, 0x20, 0x1c, 0xea, 0x91, 0x33, 0x00, 0x65, 0x38,
	0x47, 0xa5, 0x76, 0xa6, 0xb4, 0xf7, 0x0d, 0xe9, 0x64, 0x93, 0x3c, 0x42, 0xd0, 0xf5, 0x20, 0xa7,
	0xd3, 0xf4, 0x56, 0xe8, 0x4f, 0x3c, 0xc9, 0x09, 0xf8, 0x5a, 0x68, 0x56, 0xda, 0xc7, 0xf1, 0x69,
	0x37, 0x24, 0xb7, 0x10, 0x8d, 0x1d, 0x0e, 0x45, 0xbd, 0x04, 0xb0, 0xd4, 0x3f, 0x12, 0x3f, 0x03,
	0xfb, 0xbd, 0xf7, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x63, 0xb3, 0xaa, 0x22, 0xed, 0x01, 0x00,
	0x00,
}
